Архитектура игры, связанная с созданием отдельных юнитов (и не только):

1) Основной класс в игре - класс Game, в котором находится стек
существующих игровых состояний, представляемых интерфейсом State.

Персонаж: класс Player
2) Нас интересует класс GameState, который управляет игровым процессом.
Непосредственно в нём создаётся игровой персонаж (настройки загружаются
из конфигурационного файла, возможно в будущем появится выбор персонажем
игрового класса, но от этого зависит только набор характеристик и
способностей персонажа).

Player является представителем интерфейса
Creature, который, в свою очередь, хранит в себе различные компоненты
(COMPONENTS - этого нет на UML-диаграмме), которые могут быть
инициализированы из json-файла и по сути, выполняют за Creature всю
работу. 

Примечание: Player не является синглтоном, потому что этого не требуется - им
может управлять непосредственно класс игрового состояния.

3) Создание противников:
Непосредственно в GameState инициализируется уникальный указатель на объект
класса EnemySystem, который является системой управления противниками.

Здесь мы и пользуемся порождающим паттерном Prototype.
Изначально в векторе уникальных врагов создаётся по одному экземпляру
противника каждого вида и каждый получает в соответствие свой тип
(в соответствие с ячейкой вектора, в которой он лежит).

Затем, когда инициализируется монстрами вся игровая карта, мы можем
по набору чисел из конфигурационного json-файла (возможно сменим формат
для карты) вызвать метод Clone() у нужного противника из вектора
unique_enemies. Таким образом, мы создаём на карте монстров, ничего
не зная о их реализации и нам очень удобно изменять характеристики или
какие-то особенности каждого монстра.

Также выбор паттерна Prototype обоснован желанием создать особых противников,
которые умеют вызывать прислужников (EnemySpawner).
Каждый EnemySpawner при создании получает "внутрь" прототипа, который
будет клонироваться при спауне монстров, удобнее метода для спауна
и не придумаешь.

4) Карта: таким же образом создаётся карта - в векторе создаётся по 
экземпляру уникальной плитки, а затем при создании карты вызывается
метод Clone() у нужной плитки из вектора.
Здесь планировалось использование шаблона Приспособленец, но он
оказался несовместим с графической библиотекой.

5) Непосредственно создание монстров происходит с использованием
метода, немного похожего на FactoryMethod - по типу врага EnemySystem
понимает, какой экземпляр клонировать и выставлять на карту.

Подробнее в коде)

	